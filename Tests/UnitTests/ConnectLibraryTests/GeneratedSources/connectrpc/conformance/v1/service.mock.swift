// Code generated by protoc-gen-connect-swift. DO NOT EDIT.
//
// Source: connectrpc/conformance/v1/service.proto
//

import Combine
import Connect
import ConnectMocks
import Foundation
import SwiftProtobuf

/// Mock implementation of `Connectrpc_Conformance_V1_ConformanceServiceClientInterface`.
///
/// Production implementations can be substituted with instances of this
/// class to mock RPC calls. Behavior can be customized
/// either through the properties on this class or by
/// subclassing the mock and overriding its methods.
///
/// Note: This class does not handle thread-safe locking, but provides
/// `@unchecked Sendable` conformance to simplify testing and mocking.
@available(iOS 13, *)
internal class Connectrpc_Conformance_V1_ConformanceServiceClientMock: Connectrpc_Conformance_V1_ConformanceServiceClientInterface, @unchecked Sendable {
    private var cancellables = [Combine.AnyCancellable]()

    /// Mocked for calls to `unary()`.
    internal var mockUnary = { (_: Connectrpc_Conformance_V1_UnaryRequest) -> ResponseMessage<Connectrpc_Conformance_V1_UnaryResponse> in .init(result: .success(.init())) }
    /// Mocked for async calls to `unary()`.
    internal var mockAsyncUnary = { (_: Connectrpc_Conformance_V1_UnaryRequest) -> ResponseMessage<Connectrpc_Conformance_V1_UnaryResponse> in .init(result: .success(.init())) }
    /// Mocked for calls to `serverStream()`.
    internal var mockServerStream = MockServerOnlyStream<Connectrpc_Conformance_V1_ServerStreamRequest, Connectrpc_Conformance_V1_ServerStreamResponse>()
    /// Mocked for async calls to `serverStream()`.
    internal var mockAsyncServerStream = MockServerOnlyAsyncStream<Connectrpc_Conformance_V1_ServerStreamRequest, Connectrpc_Conformance_V1_ServerStreamResponse>()
    /// Mocked for calls to `clientStream()`.
    internal var mockClientStream = MockClientOnlyStream<Connectrpc_Conformance_V1_ClientStreamRequest, Connectrpc_Conformance_V1_ClientStreamResponse>()
    /// Mocked for async calls to `clientStream()`.
    internal var mockAsyncClientStream = MockClientOnlyAsyncStream<Connectrpc_Conformance_V1_ClientStreamRequest, Connectrpc_Conformance_V1_ClientStreamResponse>()
    /// Mocked for calls to `bidiStream()`.
    internal var mockBidiStream = MockBidirectionalStream<Connectrpc_Conformance_V1_BidiStreamRequest, Connectrpc_Conformance_V1_BidiStreamResponse>()
    /// Mocked for async calls to `bidiStream()`.
    internal var mockAsyncBidiStream = MockBidirectionalAsyncStream<Connectrpc_Conformance_V1_BidiStreamRequest, Connectrpc_Conformance_V1_BidiStreamResponse>()
    /// Mocked for calls to `unimplemented()`.
    internal var mockUnimplemented = { (_: Connectrpc_Conformance_V1_UnimplementedRequest) -> ResponseMessage<Connectrpc_Conformance_V1_UnimplementedResponse> in .init(result: .success(.init())) }
    /// Mocked for async calls to `unimplemented()`.
    internal var mockAsyncUnimplemented = { (_: Connectrpc_Conformance_V1_UnimplementedRequest) -> ResponseMessage<Connectrpc_Conformance_V1_UnimplementedResponse> in .init(result: .success(.init())) }
    /// Mocked for calls to `idempotentUnary()`.
    internal var mockIdempotentUnary = { (_: Connectrpc_Conformance_V1_IdempotentUnaryRequest) -> ResponseMessage<Connectrpc_Conformance_V1_IdempotentUnaryResponse> in .init(result: .success(.init())) }
    /// Mocked for async calls to `idempotentUnary()`.
    internal var mockAsyncIdempotentUnary = { (_: Connectrpc_Conformance_V1_IdempotentUnaryRequest) -> ResponseMessage<Connectrpc_Conformance_V1_IdempotentUnaryResponse> in .init(result: .success(.init())) }

    internal init() {}

    @discardableResult
    internal func `unary`(request: Connectrpc_Conformance_V1_UnaryRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Connectrpc_Conformance_V1_UnaryResponse>) -> Void) -> Connect.Cancelable {
        completion(self.mockUnary(request))
        return Connect.Cancelable {}
    }

    internal func `unary`(request: Connectrpc_Conformance_V1_UnaryRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Connectrpc_Conformance_V1_UnaryResponse> {
        return self.mockAsyncUnary(request)
    }

    internal func `serverStream`(headers: Connect.Headers = [:], onResult: @escaping @Sendable (Connect.StreamResult<Connectrpc_Conformance_V1_ServerStreamResponse>) -> Void) -> any Connect.ServerOnlyStreamInterface<Connectrpc_Conformance_V1_ServerStreamRequest> {
        self.mockServerStream.$inputs.first { !$0.isEmpty }.sink { _ in self.mockServerStream.outputs.forEach(onResult) }.store(in: &self.cancellables)
        return self.mockServerStream
    }

    internal func `serverStream`(headers: Connect.Headers = [:]) -> any Connect.ServerOnlyAsyncStreamInterface<Connectrpc_Conformance_V1_ServerStreamRequest, Connectrpc_Conformance_V1_ServerStreamResponse> {
        return self.mockAsyncServerStream
    }

    internal func `clientStream`(headers: Connect.Headers = [:], onResult: @escaping @Sendable (Connect.StreamResult<Connectrpc_Conformance_V1_ClientStreamResponse>) -> Void) -> any Connect.ClientOnlyStreamInterface<Connectrpc_Conformance_V1_ClientStreamRequest> {
        self.mockClientStream.$inputs.first { !$0.isEmpty }.sink { _ in self.mockClientStream.outputs.forEach(onResult) }.store(in: &self.cancellables)
        return self.mockClientStream
    }

    internal func `clientStream`(headers: Connect.Headers = [:]) -> any Connect.ClientOnlyAsyncStreamInterface<Connectrpc_Conformance_V1_ClientStreamRequest, Connectrpc_Conformance_V1_ClientStreamResponse> {
        return self.mockAsyncClientStream
    }

    internal func `bidiStream`(headers: Connect.Headers = [:], onResult: @escaping @Sendable (Connect.StreamResult<Connectrpc_Conformance_V1_BidiStreamResponse>) -> Void) -> any Connect.BidirectionalStreamInterface<Connectrpc_Conformance_V1_BidiStreamRequest> {
        self.mockBidiStream.$inputs.first { !$0.isEmpty }.sink { _ in self.mockBidiStream.outputs.forEach(onResult) }.store(in: &self.cancellables)
        return self.mockBidiStream
    }

    internal func `bidiStream`(headers: Connect.Headers = [:]) -> any Connect.BidirectionalAsyncStreamInterface<Connectrpc_Conformance_V1_BidiStreamRequest, Connectrpc_Conformance_V1_BidiStreamResponse> {
        return self.mockAsyncBidiStream
    }

    @discardableResult
    internal func `unimplemented`(request: Connectrpc_Conformance_V1_UnimplementedRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Connectrpc_Conformance_V1_UnimplementedResponse>) -> Void) -> Connect.Cancelable {
        completion(self.mockUnimplemented(request))
        return Connect.Cancelable {}
    }

    internal func `unimplemented`(request: Connectrpc_Conformance_V1_UnimplementedRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Connectrpc_Conformance_V1_UnimplementedResponse> {
        return self.mockAsyncUnimplemented(request)
    }

    @discardableResult
    internal func `idempotentUnary`(request: Connectrpc_Conformance_V1_IdempotentUnaryRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Connectrpc_Conformance_V1_IdempotentUnaryResponse>) -> Void) -> Connect.Cancelable {
        completion(self.mockIdempotentUnary(request))
        return Connect.Cancelable {}
    }

    internal func `idempotentUnary`(request: Connectrpc_Conformance_V1_IdempotentUnaryRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Connectrpc_Conformance_V1_IdempotentUnaryResponse> {
        return self.mockAsyncIdempotentUnary(request)
    }
}
