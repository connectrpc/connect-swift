// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: connectrpc/conformance/v1/client_compat.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023-2024 The Connect Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes one call the client should make. The client reads
/// these from stdin and, for each one, invokes an RPC as directed
/// and writes the results (in the form of a ClientCompatResponse
/// message) to stdout.
struct Connectrpc_Conformance_V1_ClientCompatRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the test that this request is performing.
  /// When writing test cases, this is a required field.
  var testName: String {
    get {return _storage._testName}
    set {_uniqueStorage()._testName = newValue}
  }

  /// Test suite YAML definitions should NOT set values for these next
  /// nine fields (fields 2 - 10). They are automatically populated by the test
  /// runner. If a test is specific to one of these values, it should instead be
  /// indicated in the test suite itself (where it defines the required
  /// features and relevant values for these fields).
  ///
  /// The HTTP version to use for the test (i.e. HTTP/1.1, HTTP/2, HTTP/3).
  var httpVersion: Connectrpc_Conformance_V1_HTTPVersion {
    get {return _storage._httpVersion}
    set {_uniqueStorage()._httpVersion = newValue}
  }

  /// The protocol to use for the test (i.e. Connect, gRPC, gRPC-web).
  var `protocol`: Connectrpc_Conformance_V1_Protocol {
    get {return _storage._protocol}
    set {_uniqueStorage()._protocol = newValue}
  }

  /// The codec to use for the test (i.e. JSON, proto/binary).
  var codec: Connectrpc_Conformance_V1_Codec {
    get {return _storage._codec}
    set {_uniqueStorage()._codec = newValue}
  }

  /// The compression to use for the test (i.e. brotli, gzip, identity).
  var compression: Connectrpc_Conformance_V1_Compression {
    get {return _storage._compression}
    set {_uniqueStorage()._compression = newValue}
  }

  /// The server host that this request will be sent to.
  var host: String {
    get {return _storage._host}
    set {_uniqueStorage()._host = newValue}
  }

  /// The server port that this request will be sent to.
  var port: UInt32 {
    get {return _storage._port}
    set {_uniqueStorage()._port = newValue}
  }

  /// If non-empty, the server is using TLS. The bytes are the
  /// server's PEM-encoded certificate, which the client should
  /// verify and trust.
  var serverTlsCert: Data {
    get {return _storage._serverTlsCert}
    set {_uniqueStorage()._serverTlsCert = newValue}
  }

  /// If present, the client certificate credentials to use to
  /// authenticate with the server. This will only be present
  /// when server_tls_cert is non-empty.
  var clientTlsCreds: Connectrpc_Conformance_V1_TLSCreds {
    get {return _storage._clientTlsCreds ?? Connectrpc_Conformance_V1_TLSCreds()}
    set {_uniqueStorage()._clientTlsCreds = newValue}
  }
  /// Returns true if `clientTlsCreds` has been explicitly set.
  var hasClientTlsCreds: Bool {return _storage._clientTlsCreds != nil}
  /// Clears the value of `clientTlsCreds`. Subsequent reads from it will return its default value.
  mutating func clearClientTlsCreds() {_uniqueStorage()._clientTlsCreds = nil}

  /// If non-zero, indicates the maximum size in bytes for a message.
  /// If the server sends anything larger, the client should reject it.
  var messageReceiveLimit: UInt32 {
    get {return _storage._messageReceiveLimit}
    set {_uniqueStorage()._messageReceiveLimit = newValue}
  }

  /// The fully-qualified name of the service this test will interact with.
  /// If specified, method must also be specified.
  /// If not specified, defaults to "connectrpc.conformance.v1.ConformanceService".
  var service: String {
    get {return _storage._service ?? String()}
    set {_uniqueStorage()._service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  var hasService: Bool {return _storage._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  mutating func clearService() {_uniqueStorage()._service = nil}

  /// The method on `service` that will be called.
  /// If specified, service must also be specified.
  /// If not specified, the test runner will auto-populate this field based on the stream_type.
  var method: String {
    get {return _storage._method ?? String()}
    set {_uniqueStorage()._method = newValue}
  }
  /// Returns true if `method` has been explicitly set.
  var hasMethod: Bool {return _storage._method != nil}
  /// Clears the value of `method`. Subsequent reads from it will return its default value.
  mutating func clearMethod() {_uniqueStorage()._method = nil}

  /// The stream type of `method` (i.e. unary, client stream, server stream, full-duplex bidi
  /// stream, or half-duplex bidi stream).
  /// When writing test cases, this is a required field.
  var streamType: Connectrpc_Conformance_V1_StreamType {
    get {return _storage._streamType}
    set {_uniqueStorage()._streamType = newValue}
  }

  /// If protocol indicates Connect and stream type indicates
  /// Unary, this instructs the client to use a GET HTTP method
  /// when making the request.
  var useGetHTTPMethod: Bool {
    get {return _storage._useGetHTTPMethod}
    set {_uniqueStorage()._useGetHTTPMethod = newValue}
  }

  /// Any request headers that should be sent as part of the request.
  /// These include only custom header metadata. Headers that are
  /// part of the relevant protocol (such as "content-type", etc) should
  /// not be stated here.
  var requestHeaders: [Connectrpc_Conformance_V1_Header] {
    get {return _storage._requestHeaders}
    set {_uniqueStorage()._requestHeaders = newValue}
  }

  /// The actual request messages that will sent to the server.
  /// The type URL for all entries should be equal to the request type of the
  /// method.
  /// There must be exactly one for unary and server stream methods but
  /// can be zero or more for client and bidi stream methods.
  /// For client and bidi stream methods, all entries will have the
  /// same type URL.
  var requestMessages: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._requestMessages}
    set {_uniqueStorage()._requestMessages = newValue}
  }

  /// The timeout, in milliseconds, for the request. This is equivalent to a
  /// deadline for the request. If unset, there will be no timeout.
  var timeoutMs: UInt32 {
    get {return _storage._timeoutMs ?? 0}
    set {_uniqueStorage()._timeoutMs = newValue}
  }
  /// Returns true if `timeoutMs` has been explicitly set.
  var hasTimeoutMs: Bool {return _storage._timeoutMs != nil}
  /// Clears the value of `timeoutMs`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutMs() {_uniqueStorage()._timeoutMs = nil}

  /// Wait this many milliseconds before sending a request message.
  /// For client or bidi stream methods, this delay should be
  /// applied before each request sent.
  var requestDelayMs: UInt32 {
    get {return _storage._requestDelayMs}
    set {_uniqueStorage()._requestDelayMs = newValue}
  }

  /// If present, the client should cancel the RPC instead of
  /// allowing to complete normally.
  var cancel: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel {
    get {return _storage._cancel ?? Connectrpc_Conformance_V1_ClientCompatRequest.Cancel()}
    set {_uniqueStorage()._cancel = newValue}
  }
  /// Returns true if `cancel` has been explicitly set.
  var hasCancel: Bool {return _storage._cancel != nil}
  /// Clears the value of `cancel`. Subsequent reads from it will return its default value.
  mutating func clearCancel() {_uniqueStorage()._cancel = nil}

  /// The following field is only used by the reference client. If
  /// you are implementing a client under test, you may ignore it
  /// or respond with an error if the client receives a request where
  /// it is set.
  ///
  /// When this field is present, it defines the actual HTTP request
  /// that will be sent. The above group of fields must still be
  /// provided and valid so that the reference client knows how it
  /// should try to interpret the server's response.
  var rawRequest: Connectrpc_Conformance_V1_RawHTTPRequest {
    get {return _storage._rawRequest ?? Connectrpc_Conformance_V1_RawHTTPRequest()}
    set {_uniqueStorage()._rawRequest = newValue}
  }
  /// Returns true if `rawRequest` has been explicitly set.
  var hasRawRequest: Bool {return _storage._rawRequest != nil}
  /// Clears the value of `rawRequest`. Subsequent reads from it will return its default value.
  mutating func clearRawRequest() {_uniqueStorage()._rawRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Cancel: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// These fields determine the timing of cancellation.
    /// If none are present, the client should cancel immediately
    /// after all request messages are sent and the send side is
    /// closed (as if the after_close_send_ms field were present
    /// and zero).
    var cancelTiming: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel.OneOf_CancelTiming? = nil

    /// When present, the client should cancel *instead of*
    /// closing the send side of the stream, after all requests
    /// have been sent.
    ///
    /// This applies only to client and bidi stream RPCs.
    var beforeCloseSend: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .beforeCloseSend(let v)? = cancelTiming {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {cancelTiming = .beforeCloseSend(newValue)}
    }

    /// When present, the client should delay for this many
    /// milliseconds after closing the send side of the stream
    /// and then cancel.
    ///
    /// This applies to all types of RPCs.
    ///
    /// For unary and server stream RPCs, where the API usually
    /// does not allow explicitly closing the send side, the
    /// cancellation should be done immediately after invoking
    /// the RPC (which should implicitly send the one-and-only
    /// request and then close the send-side).
    ///
    /// For APIs where unary RPCs block until the response
    /// is received, there is no point after the request is
    /// sent but before a response is received to cancel. So
    /// the client must arrange for the RPC to be canceled
    /// asynchronously before invoking the blocking unary call.
    var afterCloseSendMs: UInt32 {
      get {
        if case .afterCloseSendMs(let v)? = cancelTiming {return v}
        return 0
      }
      set {cancelTiming = .afterCloseSendMs(newValue)}
    }

    /// When present, the client should cancel right after
    /// reading this number of response messages from the stream.
    /// When present, this will be greater than zero.
    ///
    /// This applies only to server and bidi stream RPCs.
    var afterNumResponses: UInt32 {
      get {
        if case .afterNumResponses(let v)? = cancelTiming {return v}
        return 0
      }
      set {cancelTiming = .afterNumResponses(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// These fields determine the timing of cancellation.
    /// If none are present, the client should cancel immediately
    /// after all request messages are sent and the send side is
    /// closed (as if the after_close_send_ms field were present
    /// and zero).
    enum OneOf_CancelTiming: Equatable, Sendable {
      /// When present, the client should cancel *instead of*
      /// closing the send side of the stream, after all requests
      /// have been sent.
      ///
      /// This applies only to client and bidi stream RPCs.
      case beforeCloseSend(SwiftProtobuf.Google_Protobuf_Empty)
      /// When present, the client should delay for this many
      /// milliseconds after closing the send side of the stream
      /// and then cancel.
      ///
      /// This applies to all types of RPCs.
      ///
      /// For unary and server stream RPCs, where the API usually
      /// does not allow explicitly closing the send side, the
      /// cancellation should be done immediately after invoking
      /// the RPC (which should implicitly send the one-and-only
      /// request and then close the send-side).
      ///
      /// For APIs where unary RPCs block until the response
      /// is received, there is no point after the request is
      /// sent but before a response is received to cancel. So
      /// the client must arrange for the RPC to be canceled
      /// asynchronously before invoking the blocking unary call.
      case afterCloseSendMs(UInt32)
      /// When present, the client should cancel right after
      /// reading this number of response messages from the stream.
      /// When present, this will be greater than zero.
      ///
      /// This applies only to server and bidi stream RPCs.
      case afterNumResponses(UInt32)

    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The outcome of one ClientCompatRequest.
struct Connectrpc_Conformance_V1_ClientCompatResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The test name that this response applies to.
  var testName: String = String()

  /// These fields determine the outcome of the request.
  ///
  /// With regards to errors, any unexpected errors that prevent the client from
  /// issuing the RPC and following the instructions implied by the request can
  /// be reported as an error. These would be errors creating an RPC client from
  /// the request parameters or unsupported/illegal values in the request
  /// (e.g. a unary request that defines zero or multiple request messages).
  ///
  /// However, once the RPC is issued, any resulting error should instead be encoded in response.
  var result: Connectrpc_Conformance_V1_ClientCompatResponse.OneOf_Result? = nil

  var response: Connectrpc_Conformance_V1_ClientResponseResult {
    get {
      if case .response(let v)? = result {return v}
      return Connectrpc_Conformance_V1_ClientResponseResult()
    }
    set {result = .response(newValue)}
  }

  var error: Connectrpc_Conformance_V1_ClientErrorResult {
    get {
      if case .error(let v)? = result {return v}
      return Connectrpc_Conformance_V1_ClientErrorResult()
    }
    set {result = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// These fields determine the outcome of the request.
  ///
  /// With regards to errors, any unexpected errors that prevent the client from
  /// issuing the RPC and following the instructions implied by the request can
  /// be reported as an error. These would be errors creating an RPC client from
  /// the request parameters or unsupported/illegal values in the request
  /// (e.g. a unary request that defines zero or multiple request messages).
  ///
  /// However, once the RPC is issued, any resulting error should instead be encoded in response.
  enum OneOf_Result: Equatable, Sendable {
    case response(Connectrpc_Conformance_V1_ClientResponseResult)
    case error(Connectrpc_Conformance_V1_ClientErrorResult)

  }

  init() {}
}

/// The result of a ClientCompatRequest, which may or may not be successful.
/// The client will build this message and return it back to the test runner.
struct Connectrpc_Conformance_V1_ClientResponseResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All response headers read from the response.
  var responseHeaders: [Connectrpc_Conformance_V1_Header] = []

  /// Servers should echo back payloads that they received as part of the request.
  /// This field should contain all the payloads the server echoed back. Note that
  /// There will be zero-to-one for unary and client stream methods and
  /// zero-to-many for server and bidi stream methods.
  var payloads: [Connectrpc_Conformance_V1_ConformancePayload] = []

  /// The error received from the actual RPC invocation. Note this is not representative
  /// of a runtime error and should always be the proto equivalent of a Connect
  /// or gRPC error.
  var error: Connectrpc_Conformance_V1_Error {
    get {return _error ?? Connectrpc_Conformance_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  /// All response headers read from the response.
  var responseTrailers: [Connectrpc_Conformance_V1_Header] = []

  /// The number of messages that were present in the request but that could not be
  /// sent because an error occurred before finishing the upload.
  var numUnsentRequests: Int32 = 0

  /// The following field is only set by the reference client. It communicates
  /// the underlying HTTP status code of the server's response.
  /// If you are implementing a client-under-test, you should ignore this field
  /// and leave it unset.
  var httpStatusCode: Int32 {
    get {return _httpStatusCode ?? 0}
    set {_httpStatusCode = newValue}
  }
  /// Returns true if `httpStatusCode` has been explicitly set.
  var hasHTTPStatusCode: Bool {return self._httpStatusCode != nil}
  /// Clears the value of `httpStatusCode`. Subsequent reads from it will return its default value.
  mutating func clearHTTPStatusCode() {self._httpStatusCode = nil}

  /// This field is used only by the reference client, and it can be used
  /// to provide additional feedback about problems observed in the server
  /// response or in client processing of the response. If non-empty, the test
  /// case is considered failed even if the result above matches all expectations.
  /// If you are implementing a client-under-test, you should ignore this field
  /// and leave it unset.
  var feedback: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Connectrpc_Conformance_V1_Error? = nil
  fileprivate var _httpStatusCode: Int32? = nil
}

/// The client is not able to fulfill the ClientCompatRequest. This may be due
/// to a runtime error or an unexpected internal error such as the requested protocol
/// not being supported. This is completely independent of the actual RPC invocation.
struct Connectrpc_Conformance_V1_ClientErrorResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A message describing the error that occurred. This string will be shown to
  /// users running conformance tests so it should include any relevant details
  /// that may help troubleshoot or remedy the error.
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Details about various values as observed on the wire. This message is used
/// only by the reference client when reporting results and should not be populated
/// by clients under test.
struct Connectrpc_Conformance_V1_WireDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The HTTP status code of the response.
  var actualStatusCode: Int32 = 0

  /// When processing an error from a Connect server, this should contain
  /// the actual JSON received on the wire.
  var connectErrorRaw: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _connectErrorRaw ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_connectErrorRaw = newValue}
  }
  /// Returns true if `connectErrorRaw` has been explicitly set.
  var hasConnectErrorRaw: Bool {return self._connectErrorRaw != nil}
  /// Clears the value of `connectErrorRaw`. Subsequent reads from it will return its default value.
  mutating func clearConnectErrorRaw() {self._connectErrorRaw = nil}

  /// Any HTTP trailers observed after the response body. These do NOT
  /// include trailers that conveyed via the body, as done in the gRPC-Web
  /// and Connect streaming protocols.
  var actualHTTPTrailers: [Connectrpc_Conformance_V1_Header] = []

  /// Any trailers that were transmitted in the final message of the
  /// response body for a gRPC-Web response. This could differ from the
  /// ClientResponseResult.response_trailers field since the RPC client
  /// library might canonicalize keys and it might choose to remove
  /// "grpc-status" et al from the set of metadata. This field will
  /// capture all of the entries and their exact on-the-wire spelling
  /// and formatting.
  var actualGrpcwebTrailers: String {
    get {return _actualGrpcwebTrailers ?? String()}
    set {_actualGrpcwebTrailers = newValue}
  }
  /// Returns true if `actualGrpcwebTrailers` has been explicitly set.
  var hasActualGrpcwebTrailers: Bool {return self._actualGrpcwebTrailers != nil}
  /// Clears the value of `actualGrpcwebTrailers`. Subsequent reads from it will return its default value.
  mutating func clearActualGrpcwebTrailers() {self._actualGrpcwebTrailers = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connectErrorRaw: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _actualGrpcwebTrailers: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "connectrpc.conformance.v1"

extension Connectrpc_Conformance_V1_ClientCompatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientCompatRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_name"),
    2: .standard(proto: "http_version"),
    3: .same(proto: "protocol"),
    4: .same(proto: "codec"),
    5: .same(proto: "compression"),
    6: .same(proto: "host"),
    7: .same(proto: "port"),
    8: .standard(proto: "server_tls_cert"),
    9: .standard(proto: "client_tls_creds"),
    10: .standard(proto: "message_receive_limit"),
    11: .same(proto: "service"),
    12: .same(proto: "method"),
    13: .standard(proto: "stream_type"),
    14: .standard(proto: "use_get_http_method"),
    15: .standard(proto: "request_headers"),
    16: .standard(proto: "request_messages"),
    17: .standard(proto: "timeout_ms"),
    18: .standard(proto: "request_delay_ms"),
    19: .same(proto: "cancel"),
    20: .standard(proto: "raw_request"),
  ]

  fileprivate class _StorageClass {
    var _testName: String = String()
    var _httpVersion: Connectrpc_Conformance_V1_HTTPVersion = .unspecified
    var _protocol: Connectrpc_Conformance_V1_Protocol = .unspecified
    var _codec: Connectrpc_Conformance_V1_Codec = .unspecified
    var _compression: Connectrpc_Conformance_V1_Compression = .unspecified
    var _host: String = String()
    var _port: UInt32 = 0
    var _serverTlsCert: Data = Data()
    var _clientTlsCreds: Connectrpc_Conformance_V1_TLSCreds? = nil
    var _messageReceiveLimit: UInt32 = 0
    var _service: String? = nil
    var _method: String? = nil
    var _streamType: Connectrpc_Conformance_V1_StreamType = .unspecified
    var _useGetHTTPMethod: Bool = false
    var _requestHeaders: [Connectrpc_Conformance_V1_Header] = []
    var _requestMessages: [SwiftProtobuf.Google_Protobuf_Any] = []
    var _timeoutMs: UInt32? = nil
    var _requestDelayMs: UInt32 = 0
    var _cancel: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel? = nil
    var _rawRequest: Connectrpc_Conformance_V1_RawHTTPRequest? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _testName = source._testName
      _httpVersion = source._httpVersion
      _protocol = source._protocol
      _codec = source._codec
      _compression = source._compression
      _host = source._host
      _port = source._port
      _serverTlsCert = source._serverTlsCert
      _clientTlsCreds = source._clientTlsCreds
      _messageReceiveLimit = source._messageReceiveLimit
      _service = source._service
      _method = source._method
      _streamType = source._streamType
      _useGetHTTPMethod = source._useGetHTTPMethod
      _requestHeaders = source._requestHeaders
      _requestMessages = source._requestMessages
      _timeoutMs = source._timeoutMs
      _requestDelayMs = source._requestDelayMs
      _cancel = source._cancel
      _rawRequest = source._rawRequest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._testName) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._httpVersion) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._protocol) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._codec) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._compression) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._host) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._port) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._serverTlsCert) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._clientTlsCreds) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._messageReceiveLimit) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._service) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._streamType) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._useGetHTTPMethod) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestHeaders) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestMessages) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._timeoutMs) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._requestDelayMs) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._cancel) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._rawRequest) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._testName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._testName, fieldNumber: 1)
      }
      if _storage._httpVersion != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._httpVersion, fieldNumber: 2)
      }
      if _storage._protocol != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._protocol, fieldNumber: 3)
      }
      if _storage._codec != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._codec, fieldNumber: 4)
      }
      if _storage._compression != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._compression, fieldNumber: 5)
      }
      if !_storage._host.isEmpty {
        try visitor.visitSingularStringField(value: _storage._host, fieldNumber: 6)
      }
      if _storage._port != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._port, fieldNumber: 7)
      }
      if !_storage._serverTlsCert.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._serverTlsCert, fieldNumber: 8)
      }
      try { if let v = _storage._clientTlsCreds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._messageReceiveLimit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._messageReceiveLimit, fieldNumber: 10)
      }
      try { if let v = _storage._service {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._method {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      if _storage._streamType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._streamType, fieldNumber: 13)
      }
      if _storage._useGetHTTPMethod != false {
        try visitor.visitSingularBoolField(value: _storage._useGetHTTPMethod, fieldNumber: 14)
      }
      if !_storage._requestHeaders.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestHeaders, fieldNumber: 15)
      }
      if !_storage._requestMessages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestMessages, fieldNumber: 16)
      }
      try { if let v = _storage._timeoutMs {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 17)
      } }()
      if _storage._requestDelayMs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._requestDelayMs, fieldNumber: 18)
      }
      try { if let v = _storage._cancel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._rawRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientCompatRequest, rhs: Connectrpc_Conformance_V1_ClientCompatRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._testName != rhs_storage._testName {return false}
        if _storage._httpVersion != rhs_storage._httpVersion {return false}
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._codec != rhs_storage._codec {return false}
        if _storage._compression != rhs_storage._compression {return false}
        if _storage._host != rhs_storage._host {return false}
        if _storage._port != rhs_storage._port {return false}
        if _storage._serverTlsCert != rhs_storage._serverTlsCert {return false}
        if _storage._clientTlsCreds != rhs_storage._clientTlsCreds {return false}
        if _storage._messageReceiveLimit != rhs_storage._messageReceiveLimit {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._streamType != rhs_storage._streamType {return false}
        if _storage._useGetHTTPMethod != rhs_storage._useGetHTTPMethod {return false}
        if _storage._requestHeaders != rhs_storage._requestHeaders {return false}
        if _storage._requestMessages != rhs_storage._requestMessages {return false}
        if _storage._timeoutMs != rhs_storage._timeoutMs {return false}
        if _storage._requestDelayMs != rhs_storage._requestDelayMs {return false}
        if _storage._cancel != rhs_storage._cancel {return false}
        if _storage._rawRequest != rhs_storage._rawRequest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientCompatRequest.Cancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Connectrpc_Conformance_V1_ClientCompatRequest.protoMessageName + ".Cancel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "before_close_send"),
    2: .standard(proto: "after_close_send_ms"),
    3: .standard(proto: "after_num_responses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.cancelTiming {
          hadOneofValue = true
          if case .beforeCloseSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cancelTiming = .beforeCloseSend(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.cancelTiming != nil {try decoder.handleConflictingOneOf()}
          self.cancelTiming = .afterCloseSendMs(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.cancelTiming != nil {try decoder.handleConflictingOneOf()}
          self.cancelTiming = .afterNumResponses(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.cancelTiming {
    case .beforeCloseSend?: try {
      guard case .beforeCloseSend(let v)? = self.cancelTiming else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .afterCloseSendMs?: try {
      guard case .afterCloseSendMs(let v)? = self.cancelTiming else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case .afterNumResponses?: try {
      guard case .afterNumResponses(let v)? = self.cancelTiming else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel, rhs: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel) -> Bool {
    if lhs.cancelTiming != rhs.cancelTiming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientCompatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientCompatResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_name"),
    2: .same(proto: "response"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.testName) }()
      case 2: try {
        var v: Connectrpc_Conformance_V1_ClientResponseResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .response(v)
        }
      }()
      case 3: try {
        var v: Connectrpc_Conformance_V1_ClientErrorResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.testName.isEmpty {
      try visitor.visitSingularStringField(value: self.testName, fieldNumber: 1)
    }
    switch self.result {
    case .response?: try {
      guard case .response(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientCompatResponse, rhs: Connectrpc_Conformance_V1_ClientCompatResponse) -> Bool {
    if lhs.testName != rhs.testName {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientResponseResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientResponseResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_headers"),
    2: .same(proto: "payloads"),
    3: .same(proto: "error"),
    4: .standard(proto: "response_trailers"),
    5: .standard(proto: "num_unsent_requests"),
    6: .standard(proto: "http_status_code"),
    7: .same(proto: "feedback"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responseHeaders) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.payloads) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.responseTrailers) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.numUnsentRequests) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._httpStatusCode) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.feedback) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.responseHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseHeaders, fieldNumber: 1)
    }
    if !self.payloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payloads, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.responseTrailers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseTrailers, fieldNumber: 4)
    }
    if self.numUnsentRequests != 0 {
      try visitor.visitSingularInt32Field(value: self.numUnsentRequests, fieldNumber: 5)
    }
    try { if let v = self._httpStatusCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    if !self.feedback.isEmpty {
      try visitor.visitRepeatedStringField(value: self.feedback, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientResponseResult, rhs: Connectrpc_Conformance_V1_ClientResponseResult) -> Bool {
    if lhs.responseHeaders != rhs.responseHeaders {return false}
    if lhs.payloads != rhs.payloads {return false}
    if lhs._error != rhs._error {return false}
    if lhs.responseTrailers != rhs.responseTrailers {return false}
    if lhs.numUnsentRequests != rhs.numUnsentRequests {return false}
    if lhs._httpStatusCode != rhs._httpStatusCode {return false}
    if lhs.feedback != rhs.feedback {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientErrorResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientErrorResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientErrorResult, rhs: Connectrpc_Conformance_V1_ClientErrorResult) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_WireDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WireDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "actual_status_code"),
    2: .standard(proto: "connect_error_raw"),
    3: .standard(proto: "actual_http_trailers"),
    4: .standard(proto: "actual_grpcweb_trailers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.actualStatusCode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._connectErrorRaw) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.actualHTTPTrailers) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._actualGrpcwebTrailers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.actualStatusCode != 0 {
      try visitor.visitSingularInt32Field(value: self.actualStatusCode, fieldNumber: 1)
    }
    try { if let v = self._connectErrorRaw {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.actualHTTPTrailers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actualHTTPTrailers, fieldNumber: 3)
    }
    try { if let v = self._actualGrpcwebTrailers {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_WireDetails, rhs: Connectrpc_Conformance_V1_WireDetails) -> Bool {
    if lhs.actualStatusCode != rhs.actualStatusCode {return false}
    if lhs._connectErrorRaw != rhs._connectErrorRaw {return false}
    if lhs.actualHTTPTrailers != rhs.actualHTTPTrailers {return false}
    if lhs._actualGrpcwebTrailers != rhs._actualGrpcwebTrailers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
